"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.Webhook = exports.Callback = void 0;
var _1 = __importDefault(require("."));
var rmoas_types_1 = require("./rmoas.types");
var find_schema_definition_1 = __importDefault(require("./lib/find-schema-definition"));
var get_parameters_as_json_schema_1 = __importDefault(require("./operation/get-parameters-as-json-schema"));
var get_response_as_json_schema_1 = __importDefault(require("./operation/get-response-as-json-schema"));
var get_requestbody_examples_1 = __importDefault(require("./operation/get-requestbody-examples"));
var get_callback_examples_1 = __importDefault(require("./operation/get-callback-examples"));
var get_response_examples_1 = __importDefault(require("./operation/get-response-examples"));
var matches_mimetype_1 = __importDefault(require("./lib/matches-mimetype"));
var Operation = /** @class */ (function () {
    function Operation(api, path, method, operation) {
        this.schema = operation;
        this.api = api instanceof _1["default"] ? api.getDefinition() : api;
        this.path = path;
        this.method = method;
        this.contentType = undefined;
        this.requestBodyExamples = undefined;
        this.responseExamples = undefined;
        this.callbackExamples = undefined;
    }
    Operation.prototype.getContentType = function () {
        var _this = this;
        if (this.contentType) {
            return this.contentType;
        }
        var types = [];
        if (this.schema.requestBody) {
            if ('$ref' in this.schema.requestBody) {
                this.schema.requestBody = (0, find_schema_definition_1["default"])(this.schema.requestBody.$ref, this.api);
            }
            if ('content' in this.schema.requestBody) {
                types = Object.keys(this.schema.requestBody.content);
            }
        }
        this.contentType = 'application/json';
        if (types && types.length) {
            this.contentType = types[0];
        }
        // Favor JSON if it exists
        types.forEach(function (t) {
            if (t.match(/json/)) {
                _this.contentType = t;
            }
        });
        return this.contentType;
    };
    Operation.prototype.isFormUrlEncoded = function () {
        return matches_mimetype_1["default"].formUrlEncoded(this.getContentType());
    };
    Operation.prototype.isMultipart = function () {
        return matches_mimetype_1["default"].multipart(this.getContentType());
    };
    Operation.prototype.isJson = function () {
        return matches_mimetype_1["default"].json(this.getContentType());
    };
    Operation.prototype.isXml = function () {
        return matches_mimetype_1["default"].xml(this.getContentType());
    };
    /**
     * Returns an array of all security requirements associated wtih this operation. If none are defined at the operation
     * level, the securities for the entire API definition are returned (with an empty array as a final fallback).
     *
     * @returns Array of security requirement objects.
     */
    Operation.prototype.getSecurity = function () {
        var _a, _b;
        if (!((_b = (_a = this.api) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b.securitySchemes)) {
            return [];
        }
        return this.schema.security || this.api.security || [];
    };
    /**
     * @see {@link https://swagger.io/docs/specification/authentication/#multiple}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}
     * @param filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent security schemes,
     *    rather than returning `false`.
     * @returns An array of arrays of objects of grouped security schemes. The inner array determines and-grouped
     *    security schemes, the outer array determines or-groups.
     */
    Operation.prototype.getSecurityWithTypes = function (filterInvalid) {
        var _this = this;
        if (filterInvalid === void 0) { filterInvalid = false; }
        var securityRequirements = this.getSecurity();
        return securityRequirements.map(function (requirement) {
            var keys;
            try {
                keys = Object.keys(requirement);
            }
            catch (e) {
                return false;
            }
            var keysWithTypes = keys.map(function (key) {
                var security;
                try {
                    // Remove the reference type, because we know this will be dereferenced
                    security = _this.api.components.securitySchemes[key];
                }
                catch (e) {
                    return false;
                }
                if (!security)
                    return false;
                var type = null;
                if (security.type === 'http') {
                    if (security.scheme === 'basic')
                        type = 'Basic';
                    else if (security.scheme === 'bearer')
                        type = 'Bearer';
                    else
                        type = security.type;
                }
                else if (security.type === 'oauth2') {
                    type = 'OAuth2';
                }
                else if (security.type === 'apiKey') {
                    if (security["in"] === 'query')
                        type = 'Query';
                    else if (security["in"] === 'header')
                        type = 'Header';
                    else if (security["in"] === 'cookie')
                        type = 'Cookie';
                    else
                        type = security.type;
                }
                else {
                    return false;
                }
                security._key = key;
                return { type: type, security: security };
            });
            if (filterInvalid)
                return keysWithTypes.filter(function (key) { return key !== false; });
            return keysWithTypes;
        });
    };
    /**
     * @returns An object where the keys are unique scheme types, and the values are arrays containing each security
     *    scheme of that type.
     */
    Operation.prototype.prepareSecurity = function () {
        var securitiesWithTypes = this.getSecurityWithTypes();
        return securitiesWithTypes.reduce(function (prev, securities) {
            if (!securities)
                return prev;
            securities.forEach(function (security) {
                // Remove non-existent schemes
                if (!security)
                    return;
                if (!prev[security.type])
                    prev[security.type] = [];
                // Only add schemes we haven't seen yet.
                var exists = prev[security.type].findIndex(function (sec) { return sec._key === security.security._key; });
                if (exists < 0) {
                    prev[security.type].push(security.security);
                }
            });
            return prev;
        }, {});
    };
    Operation.prototype.getHeaders = function () {
        var _this = this;
        this.headers = {
            request: [],
            response: []
        };
        var security = this.prepareSecurity();
        if (security.Header) {
            this.headers.request = security.Header.map(function (h) {
                return h.name;
            });
        }
        if (security.Bearer || security.Basic) {
            this.headers.request.push('Authorization');
        }
        if (security.Cookie) {
            this.headers.request.push('Cookie');
        }
        if (this.schema.parameters) {
            this.headers.request = this.headers.request.concat(
            // Remove the reference object because we will have already dereferenced
            this.schema.parameters
                .map(function (p) {
                if (p["in"] && p["in"] === 'header')
                    return p.name;
                return undefined;
            })
                .filter(function (p) { return p; }));
        }
        this.headers.response = Object.keys(this.schema.responses)
            // Remove the reference object because we will have already dereferenced
            .filter(function (r) { return _this.schema.responses[r].headers; })
            .map(function (r) {
            // Remove the reference object because we will have already dereferenced
            return Object.keys(_this.schema.responses[r].headers);
        })
            .reduce(function (a, b) { return a.concat(b); }, []);
        // If the operation doesn't already specify a 'content-type' request header,
        // we check if the path operation request body contains content, which implies that
        // we should also include the 'content-type' header.
        if (!this.headers.request.includes('Content-Type') && this.schema.requestBody) {
            if (this.schema.requestBody.content &&
                Object.keys(this.schema.requestBody.content)) {
                this.headers.request.push('Content-Type');
            }
        }
        // This is a similar approach, but in this case if we check the response content
        // and prioritize the 'accept' request header and 'content-type' request header
        if (this.schema.responses) {
            if (Object.keys(this.schema.responses).some(function (response) { return !!_this.schema.responses[response].content; })) {
                if (!this.headers.request.includes('Accept'))
                    this.headers.request.push('Accept');
                if (!this.headers.response.includes('Content-Type'))
                    this.headers.response.push('Content-Type');
            }
        }
        return this.headers;
    };
    /**
     * @returns If the operation has an `operationId` present in its schema.
     */
    Operation.prototype.hasOperationId = function () {
        return 'operationId' in this.schema;
    };
    /**
     * Retrieve an operation ID for this operation. If one is not present (it's not required by the spec!) a hash of the
     * path and method will be returned instead.
     *
     * @returns The found or generated operation ID.
     */
    Operation.prototype.getOperationId = function () {
        if ('operationId' in this.schema) {
            return this.schema.operationId;
        }
        var url = this.path
            .replace(/[^a-zA-Z0-9]/g, '-') // Remove weird characters
            .replace(/^-|-$/g, '') // Don't start or end with -
            .replace(/--+/g, '-') // Remove double --'s
            .toLowerCase();
        return this.method.toLowerCase() + "_" + url;
    };
    /**
     * @returns An array of all tags, and their metadata, that exist on this operation.
     */
    Operation.prototype.getTags = function () {
        if (!('tags' in this.schema)) {
            return [];
        }
        var oasTags = new Map();
        if ('tags' in this.api) {
            this.api.tags.forEach(function (tag) {
                oasTags.set(tag.name, tag);
            });
        }
        var tags = [];
        if (Array.isArray(this.schema.tags)) {
            this.schema.tags.forEach(function (tag) {
                if (oasTags.has(tag)) {
                    tags.push(oasTags.get(tag));
                }
                else {
                    tags.push({
                        name: tag
                    });
                }
            });
        }
        return tags;
    };
    /**
     * @returns If the operation is flagged as `deprecated` or not.
     */
    Operation.prototype.isDeprecated = function () {
        return 'deprecated' in this.schema ? this.schema.deprecated : false;
    };
    /**
     * @todo This should also pull in common params.
     * @returns The parameters (non-request body) on the operation.
     */
    Operation.prototype.getParameters = function () {
        return ('parameters' in this.schema ? this.schema.parameters : []);
    };
    /**
     * Convert the operation into an array of JSON Schema for each available type of parameter available on the operation.
     * `globalDefaults` contains an object of user defined parameter defaults used.
     *
     * @param globalDefaults An object of global defaults to apply as a `default` in the returned JSON Schema.
     * @returns An array of JSON Schema objects.
     */
    Operation.prototype.getParametersAsJsonSchema = function (globalDefaults) {
        return (0, get_parameters_as_json_schema_1["default"])(this.path, this.schema, this.api, globalDefaults);
    };
    /**
     * Get a single response for this status code, formatted as JSON schema.
     *
     * @param statusCode Status code to pull a JSON Schema object for.
     * @returns A JSON Schema object for the specified response.
     */
    Operation.prototype.getResponseAsJsonSchema = function (statusCode) {
        return (0, get_response_as_json_schema_1["default"])(this, this.api, statusCode);
    };
    /**
     * @returns An array of all valid response status codes for this operation.
     */
    Operation.prototype.getResponseStatusCodes = function () {
        return this.schema.responses ? Object.keys(this.schema.responses) : [];
    };
    /**
     * @returns If the operation has a request body.
     */
    Operation.prototype.hasRequestBody = function () {
        return !!this.schema.requestBody;
    };
    /**
     * @returns An array of request body examples that this operation has.
     */
    Operation.prototype.getRequestBodyExamples = function () {
        if (this.requestBodyExamples) {
            return this.requestBodyExamples;
        }
        this.requestBodyExamples = (0, get_requestbody_examples_1["default"])(this.schema);
        return this.requestBodyExamples;
    };
    /**
     * @param statusCode HTTP status code to get.
     * @returns A specific response out of the operation by a given HTTP status code.
     */
    Operation.prototype.getResponseByStatusCode = function (statusCode) {
        if (!this.schema.responses) {
            return false;
        }
        if (typeof this.schema.responses[statusCode] === 'undefined') {
            return false;
        }
        var response = this.schema.responses[statusCode];
        if ((0, rmoas_types_1.isRef)(response)) {
            return false;
        }
        // Remove the reference from the type, because it will already be dereferenced.
        return response;
    };
    /**
     * @returns An array of response examples that this operation has.
     */
    Operation.prototype.getResponseExamples = function () {
        if (this.responseExamples) {
            return this.responseExamples;
        }
        // @todo Remove this `as` once we convert getResponseExamples
        this.responseExamples = (0, get_response_examples_1["default"])(this.schema);
        return this.responseExamples;
    };
    /**
     * @returns If the operation has callbacks.
     */
    Operation.prototype.hasCallbacks = function () {
        return !!this.schema.callbacks;
    };
    /**
     * Retrieve a specific callback.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callbackObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     * @param identifier Callback identifier to look for.
     * @param expression Callback expression to look for.
     * @param method HTTP Method on the callback to look for.
     * @returns The found callback.
     */
    Operation.prototype.getCallback = function (identifier, expression, method) {
        if (!this.schema.callbacks)
            return false;
        // The usage of `as` in the below is to remove the possibility of a ref type, since we've dereferenced.
        var callback = this.schema.callbacks[identifier]
            ? this.schema.callbacks[identifier][expression]
            : false;
        if (!callback || !callback[method])
            return false;
        return new Callback(this.api, expression, method, callback[method], identifier);
    };
    /**
     * @returns An array of operations created from each callback.
     */
    Operation.prototype.getCallbacks = function () {
        var _this = this;
        var callbackOperations = [];
        if (!this.hasCallbacks())
            return false;
        Object.keys(this.schema.callbacks).forEach(function (callback) {
            Object.keys(_this.schema.callbacks[callback]).forEach(function (expression) {
                var cb = _this.schema.callbacks[callback];
                if (!(0, rmoas_types_1.isRef)(cb)) {
                    var exp = cb[expression];
                    if (!(0, rmoas_types_1.isRef)(exp)) {
                        Object.keys(exp).forEach(function (method) {
                            callbackOperations.push(_this.getCallback(callback, expression, method));
                        });
                    }
                }
            });
        });
        return callbackOperations;
    };
    /**
     * @returns An array of callback examples that this operation has.
     */
    Operation.prototype.getCallbackExamples = function () {
        if (this.callbackExamples) {
            return this.callbackExamples;
        }
        this.callbackExamples = (0, get_callback_examples_1["default"])(this.schema);
        return this.callbackExamples;
    };
    /**
     * Determine if a given a custom specification extension exists within the operation.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
     * @param extension Specification extension to lookup.
     * @returns The extension exists.
     */
    Operation.prototype.hasExtension = function (extension) {
        return Boolean(this.schema && extension in this.schema);
    };
    /**
     * Retrieve a custom specification extension off of the operation.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
     * @param extension Specification extension to lookup.
     * @returns The extension contents if it was found.
     */
    Operation.prototype.getExtension = function (extension) {
        var _a;
        return (_a = this.schema) === null || _a === void 0 ? void 0 : _a[extension];
    };
    return Operation;
}());
exports["default"] = Operation;
var Callback = /** @class */ (function (_super) {
    __extends(Callback, _super);
    function Callback(api, path, method, operation, identifier) {
        var _this = _super.call(this, api, path, method, operation) || this;
        _this.identifier = identifier;
        return _this;
    }
    /**
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     * @returns The primary identifier for this callback.
     */
    Callback.prototype.getIdentifier = function () {
        return this.identifier;
    };
    return Callback;
}(Operation));
exports.Callback = Callback;
var Webhook = /** @class */ (function (_super) {
    __extends(Webhook, _super);
    function Webhook() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Webhook;
}(Operation));
exports.Webhook = Webhook;
